{"id":"node_modules/airbnb-prop-types/build/mutuallyExclusiveProps.js","dependencies":[{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/airbnb-prop-types/build/mutuallyExclusiveProps.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/package.json","includedInParent":true,"mtime":1574135091811},{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/airbnb-prop-types/package.json","includedInParent":true,"mtime":1574134609548},{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/airbnb-prop-types/.babelrc","includedInParent":true,"mtime":499162500000},{"name":"./helpers/wrapValidator","loc":{"line":8,"column":52},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/airbnb-prop-types/build/mutuallyExclusiveProps.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/airbnb-prop-types/build/helpers/wrapValidator.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = mutuallyExclusiveOfType;\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction mutuallyExclusiveOfType(propType) {\n  if (typeof propType !== 'function') {\n    throw new TypeError('a propType is required');\n  }\n\n  for (var _len = arguments.length, exclusiveProps = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    exclusiveProps[_key - 1] = arguments[_key];\n  }\n\n  if (exclusiveProps.length < 1) {\n    throw new TypeError('at least one prop that is mutually exclusive with this propType is required');\n  }\n\n  var propList = exclusiveProps.join(', or ');\n  var map = exclusiveProps.reduce(function (acc, prop) {\n    return _objectSpread({}, acc, _defineProperty({}, prop, true));\n  }, {});\n\n  var countProps = function countProps(count, prop) {\n    return count + (map[prop] ? 1 : 0);\n  };\n\n  var validator = function mutuallyExclusiveProps(props, propName, componentName) {\n    var exclusivePropCount = Object.keys(props).filter(function (prop) {\n      return props[prop] != null;\n    }).reduce(countProps, 0);\n\n    if (exclusivePropCount > 1) {\n      return new Error(\"A \".concat(componentName, \" cannot have more than one of these props: \").concat(propList));\n    }\n\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      rest[_key2 - 3] = arguments[_key2];\n    }\n\n    return propType.apply(void 0, [props, propName, componentName].concat(rest));\n  };\n\n  validator.isRequired = function mutuallyExclusivePropsRequired(props, propName, componentName) {\n    var exclusivePropCount = Object.keys(props).filter(function (prop) {\n      return prop === propName || props[prop] != null;\n    }).reduce(countProps, 0);\n\n    if (exclusivePropCount > 1) {\n      return new Error(\"A \".concat(componentName, \" cannot have more than one of these props: \").concat(propList));\n    }\n\n    for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      rest[_key3 - 3] = arguments[_key3];\n    }\n\n    return propType.apply(void 0, [props, propName, componentName].concat(rest));\n  };\n\n  return (0, _wrapValidator[\"default\"])(validator, \"mutuallyExclusiveProps:\".concat(propList), exclusiveProps);\n}\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/mutuallyExclusiveProps.js"],"names":["mutuallyExclusiveOfType","propType","TypeError","exclusiveProps","length","propList","join","map","reduce","acc","prop","countProps","count","validator","mutuallyExclusiveProps","props","propName","componentName","exclusivePropCount","Object","keys","filter","Error","rest","isRequired","mutuallyExclusivePropsRequired"],"mappings":";;;;;;;AAAA;;;;;;;;;;AAEe,SAASA,uBAAT,CAAiCC,QAAjC,EAA8D;AAC3E,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,UAAM,IAAIC,SAAJ,CAAc,wBAAd,CAAN;AACD;;AAH0E,oCAAhBC,cAAgB;AAAhBA,IAAAA,cAAgB;AAAA;;AAK3E,MAAIA,cAAc,CAACC,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,UAAM,IAAIF,SAAJ,CAAc,6EAAd,CAAN;AACD;;AAED,MAAMG,QAAQ,GAAGF,cAAc,CAACG,IAAf,CAAoB,OAApB,CAAjB;AAEA,MAAMC,GAAG,GAAGJ,cAAc,CAACK,MAAf,CAAsB,UAACC,GAAD,EAAMC,IAAN;AAAA,6BAAqBD,GAArB,sBAA2BC,IAA3B,EAAkC,IAAlC;AAAA,GAAtB,EAAiE,EAAjE,CAAZ;;AACA,MAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,KAAD,EAAQF,IAAR;AAAA,WAAkBE,KAAK,IAAIL,GAAG,CAACG,IAAD,CAAH,GAAY,CAAZ,GAAgB,CAApB,CAAvB;AAAA,GAAnB;;AAEA,MAAMG,SAAS,GAAG,SAASC,sBAAT,CAAgCC,KAAhC,EAAuCC,QAAvC,EAAiDC,aAAjD,EAAyE;AACzF,QAAMC,kBAAkB,GAAGC,MAAM,CAACC,IAAP,CAAYL,KAAZ,EACxBM,MADwB,CACjB,UAACX,IAAD;AAAA,aAAUK,KAAK,CAACL,IAAD,CAAL,IAAe,IAAzB;AAAA,KADiB,EAExBF,MAFwB,CAEjBG,UAFiB,EAEL,CAFK,CAA3B;;AAGA,QAAIO,kBAAkB,GAAG,CAAzB,EAA4B;AAC1B,aAAO,IAAII,KAAJ,aAAeL,aAAf,wDAA0EZ,QAA1E,EAAP;AACD;;AANwF,uCAANkB,IAAM;AAANA,MAAAA,IAAM;AAAA;;AAOzF,WAAOtB,QAAQ,MAAR,UAASc,KAAT,EAAgBC,QAAhB,EAA0BC,aAA1B,SAA4CM,IAA5C,EAAP;AACD,GARD;;AAUAV,EAAAA,SAAS,CAACW,UAAV,GAAuB,SAASC,8BAAT,CACrBV,KADqB,EAErBC,QAFqB,EAGrBC,aAHqB,EAKrB;AACA,QAAMC,kBAAkB,GAAGC,MAAM,CAACC,IAAP,CAAYL,KAAZ,EACxBM,MADwB,CACjB,UAACX,IAAD;AAAA,aAAUA,IAAI,KAAKM,QAAT,IAAqBD,KAAK,CAACL,IAAD,CAAL,IAAe,IAA9C;AAAA,KADiB,EAExBF,MAFwB,CAEjBG,UAFiB,EAEL,CAFK,CAA3B;;AAGA,QAAIO,kBAAkB,GAAG,CAAzB,EAA4B;AAC1B,aAAO,IAAII,KAAJ,aAAeL,aAAf,wDAA0EZ,QAA1E,EAAP;AACD;;AAND,uCADGkB,IACH;AADGA,MAAAA,IACH;AAAA;;AAOA,WAAOtB,QAAQ,MAAR,UAASc,KAAT,EAAgBC,QAAhB,EAA0BC,aAA1B,SAA4CM,IAA5C,EAAP;AACD,GAbD;;AAeA,SAAO,+BAAcV,SAAd,mCAAmDR,QAAnD,GAA+DF,cAA/D,CAAP;AACD","sourcesContent":["import wrapValidator from './helpers/wrapValidator';\n\nexport default function mutuallyExclusiveOfType(propType, ...exclusiveProps) {\n  if (typeof propType !== 'function') {\n    throw new TypeError('a propType is required');\n  }\n\n  if (exclusiveProps.length < 1) {\n    throw new TypeError('at least one prop that is mutually exclusive with this propType is required');\n  }\n\n  const propList = exclusiveProps.join(', or ');\n\n  const map = exclusiveProps.reduce((acc, prop) => ({ ...acc, [prop]: true }), {});\n  const countProps = (count, prop) => (count + (map[prop] ? 1 : 0));\n\n  const validator = function mutuallyExclusiveProps(props, propName, componentName, ...rest) {\n    const exclusivePropCount = Object.keys(props)\n      .filter((prop) => props[prop] != null)\n      .reduce(countProps, 0);\n    if (exclusivePropCount > 1) {\n      return new Error(`A ${componentName} cannot have more than one of these props: ${propList}`);\n    }\n    return propType(props, propName, componentName, ...rest);\n  };\n\n  validator.isRequired = function mutuallyExclusivePropsRequired(\n    props,\n    propName,\n    componentName,\n    ...rest\n  ) {\n    const exclusivePropCount = Object.keys(props)\n      .filter((prop) => prop === propName || props[prop] != null)\n      .reduce(countProps, 0);\n    if (exclusivePropCount > 1) {\n      return new Error(`A ${componentName} cannot have more than one of these props: ${propList}`);\n    }\n    return propType(props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, `mutuallyExclusiveProps:${propList}`, exclusiveProps);\n}\n"],"file":"mutuallyExclusiveProps.js"}},"error":null,"hash":"57c113368c45eaadee8f739dd8975465","cacheData":{"env":{}}}