{"id":"node_modules/enzyme/build/RSTTraversal.js","dependencies":[{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/package.json","includedInParent":true,"mtime":1574135091811},{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/package.json","includedInParent":true,"mtime":1574134608152},{"name":"object.assign","loc":{"line":23,"column":22},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/RSTTraversal.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/object.assign/index.js"},{"name":"array.prototype.flat","loc":{"line":27,"column":30},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/RSTTraversal.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/array.prototype.flat/index.js"},{"name":"object.entries","loc":{"line":31,"column":23},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/RSTTraversal.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/object.entries/index.js"},{"name":"is-subset","loc":{"line":35,"column":24},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/RSTTraversal.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/is-subset/index.js"},{"name":"function.prototype.name","loc":{"line":39,"column":33},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/RSTTraversal.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/function.prototype.name/index.js"},{"name":"is-regex","loc":{"line":43,"column":23},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/RSTTraversal.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/is-regex/index.js"},{"name":"./getAdapter","loc":{"line":47,"column":26},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/RSTTraversal.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme/build/getAdapter.js"}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.propsOfNode = propsOfNode;\nexports.childrenOfNode = childrenOfNode;\nexports.hasClassName = hasClassName;\nexports.treeForEach = treeForEach;\nexports.treeFilter = treeFilter;\nexports.findParentNode = findParentNode;\nexports.pathToNode = pathToNode;\nexports.parentsOfNode = parentsOfNode;\nexports.nodeHasId = nodeHasId;\nexports.nodeMatchesObjectProps = nodeMatchesObjectProps;\nexports.getTextFromNode = getTextFromNode;\nexports.getTextFromHostNodes = getTextFromHostNodes;\nexports.getHTMLFromHostNodes = getHTMLFromHostNodes;\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _object3 = require('object.entries');\n\nvar _object4 = _interopRequireDefault(_object3);\n\nvar _isSubset = require('is-subset');\n\nvar _isSubset2 = _interopRequireDefault(_isSubset);\n\nvar _functionPrototype = require('function.prototype.name');\n\nvar _functionPrototype2 = _interopRequireDefault(_functionPrototype);\n\nvar _isRegex = require('is-regex');\n\nvar _isRegex2 = _interopRequireDefault(_isRegex);\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction propsOfNode(node) {\n  return node && node.props || {};\n}\n\nfunction childrenOfNode(node) {\n  if (!node) return [];\n\n  var adapter = (0, _getAdapter2['default'])();\n  var adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n\n  var renderedArray = Array.isArray(node.rendered) ? (0, _arrayPrototype2['default'])(node.rendered, 1) : [node.rendered];\n\n  // React adapters before 16 will not have isFragment\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return (0, _arrayPrototype2['default'])(renderedArray.map(function (currentChild) {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nfunction hasClassName(node, className) {\n  var classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if ((0, _isRegex2['default'])(className)) return className.test(classes);\n  return (' ' + String(classes) + ' ').indexOf(' ' + String(className) + ' ') > -1;\n}\n\nfunction treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n  childrenOfNode(tree).forEach(function (node) {\n    return treeForEach(node, fn);\n  });\n}\n\nfunction treeFilter(tree, fn) {\n  var results = [];\n  treeForEach(tree, function (node) {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\nfunction findParentNode(root, targetNode) {\n  var results = treeFilter(root, function (node) {\n    if (!node.rendered) {\n      return false;\n    }\n\n    return childrenOfNode(node).indexOf(targetNode) !== -1;\n  });\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter(function (tree) {\n    return treeFilter(tree, fn).length !== 0;\n  });\n}\n\nfunction pathToNode(node, root) {\n  var queue = [root];\n  var path = [];\n\n  var hasNode = function hasNode(testNode) {\n    return node === testNode;\n  };\n\n  while (queue.length) {\n    var current = queue.pop();\n    var children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n    queue.push.apply(queue, _toConsumableArray(children));\n  }\n\n  return null;\n}\n\nfunction parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nfunction nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nvar CAN_NEVER_MATCH = {};\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\nfunction replaceUndefinedValues(obj) {\n  return (0, _object4['default'])(obj).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        k = _ref2[0],\n        v = _ref2[1];\n\n    return (0, _object2['default'])({}, acc, _defineProperty({}, k, replaceUndefined(v)));\n  }, {});\n}\n\nfunction nodeMatchesObjectProps(node, props) {\n  return (0, _isSubset2['default'])(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n  if (!hostNode) {\n    return '';\n  }\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, _ref3) {\n  var getCustom = _ref3.getCustom,\n      handleHostNodes = _ref3.handleHostNodes,\n      recurse = _ref3.recurse,\n      _ref3$nullRenderRetur = _ref3.nullRenderReturnsNull,\n      nullRenderReturnsNull = _ref3$nullRenderRetur === undefined ? false : _ref3$nullRenderRetur;\n\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nfunction getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom: function () {\n      function getCustom(_ref4) {\n        var type = _ref4.type;\n\n        return '<' + String(type.displayName || (0, _functionPrototype2['default'])(type)) + ' />';\n      }\n\n      return getCustom;\n    }()\n  });\n}\n\nfunction getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse: function () {\n      function recurse(item) {\n        return getTextFromHostNodes(item, adapter);\n      }\n\n      return recurse;\n    }(),\n    handleHostNodes: function () {\n      function handleHostNodes(item) {\n        var nodes = [].concat(adapter.nodeToHostNode(item, true));\n        return nodes.map(getTextFromHostNode).join('');\n      }\n\n      return handleHostNodes;\n    }()\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nfunction getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse: function () {\n      function recurse(item) {\n        return getHTMLFromHostNodes(item, adapter);\n      }\n\n      return recurse;\n    }(),\n    handleHostNodes: function () {\n      function handleHostNodes(item) {\n        var nodes = [].concat(adapter.nodeToHostNode(item, true));\n        return nodes.map(getHTMLFromHostNode).join('');\n      }\n\n      return handleHostNodes;\n    }(),\n\n    nullRenderReturnsNull: true\n  });\n}\n\n//# sourceMappingURL=RSTTraversal.js.map"},"sourceMaps":{"js":{"version":3,"sources":["../src/RSTTraversal.js"],"names":["propsOfNode","childrenOfNode","hasClassName","treeForEach","treeFilter","findParentNode","pathToNode","parentsOfNode","nodeHasId","nodeMatchesObjectProps","getTextFromNode","getTextFromHostNodes","getHTMLFromHostNodes","node","props","adapter","adapterHasIsFragment","isFragment","renderedArray","Array","isArray","rendered","map","currentChild","className","classes","String","replace","test","indexOf","tree","fn","forEach","results","push","root","targetNode","pathFilter","path","filter","length","queue","hasNode","testNode","current","pop","children","reverse","id","CAN_NEVER_MATCH","replaceUndefined","v","replaceUndefinedValues","obj","reduce","acc","k","getTextFromHostNode","hostNode","textContent","getTextFromRSTNode","getCustom","handleHostNodes","recurse","nullRenderReturnsNull","type","nodeType","join","displayName","item","nodes","concat","nodeToHostNode","getHTMLFromHostNode","outerHTML"],"mappings":";;;;;;;;QAOgBA,W,GAAAA,W;QAIAC,c,GAAAA,c;QAuBAC,Y,GAAAA,Y;QAOAC,W,GAAAA,W;QAOAC,U,GAAAA,U;QAoBAC,c,GAAAA,c;QAkBAC,U,GAAAA,U;QAuBAC,a,GAAAA,a;QAIAC,S,GAAAA,S;QAaAC,sB,GAAAA,sB;QAyCAC,e,GAAAA,e;QASAC,oB,GAAAA,oB;QAmBAC,oB,GAAAA,oB;;;;;;AAnMhB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;AAEO,SAASZ,WAAT,CAAqBa,IAArB,EAA2B;AAChC,SAAQA,QAAQA,KAAKC,KAAd,IAAwB,EAA/B;AACD;;AAEM,SAASb,cAAT,CAAwBY,IAAxB,EAA8B;AACnC,MAAI,CAACA,IAAL,EAAW,OAAO,EAAP;;AAEX,MAAME,UAAU,8BAAhB;AACA,MAAMC,uBAAuBD,QAAQE,UAAR,IAAsB,OAAOF,QAAQE,UAAf,KAA8B,UAAjF;;AAEA,MAAMC,gBAAgBC,MAAMC,OAAN,CAAcP,KAAKQ,QAAnB,IAA+B,iCAAKR,KAAKQ,QAAV,EAAoB,CAApB,CAA/B,GAAwD,CAACR,KAAKQ,QAAN,CAA9E;;AAEA;AACA,MAAI,CAACL,oBAAL,EAA2B;AACzB,WAAOE,aAAP;AACD;;AAED,SAAO,iCAAKA,cAAcI,GAAd,CAAkB,UAACC,YAAD,EAAkB;AAC9C;AACA,QAAIR,QAAQE,UAAR,CAAmBM,YAAnB,CAAJ,EAAsC;AACpC,aAAOtB,eAAesB,YAAf,CAAP;AACD;;AAED,WAAOA,YAAP;AACD,GAPW,CAAL,EAOH,CAPG,CAAP;AAQD;;AAEM,SAASrB,YAAT,CAAsBW,IAAtB,EAA4BW,SAA5B,EAAuC;AAC5C,MAAIC,UAAUzB,YAAYa,IAAZ,EAAkBW,SAAlB,IAA+B,EAA7C;AACAC,YAAUC,OAAOD,OAAP,EAAgBE,OAAhB,CAAwB,KAAxB,EAA+B,GAA/B,CAAV;AACA,MAAI,0BAAQH,SAAR,CAAJ,EAAwB,OAAOA,UAAUI,IAAV,CAAeH,OAAf,CAAP;AACxB,SAAO,cAAIA,OAAJ,SAAeI,OAAf,cAA2BL,SAA3B,WAA2C,CAAC,CAAnD;AACD;;AAEM,SAASrB,WAAT,CAAqB2B,IAArB,EAA2BC,EAA3B,EAA+B;AACpC,MAAID,IAAJ,EAAU;AACRC,OAAGD,IAAH;AACD;AACD7B,iBAAe6B,IAAf,EAAqBE,OAArB,CAA6B;AAAA,WAAQ7B,YAAYU,IAAZ,EAAkBkB,EAAlB,CAAR;AAAA,GAA7B;AACD;;AAEM,SAAS3B,UAAT,CAAoB0B,IAApB,EAA0BC,EAA1B,EAA8B;AACnC,MAAME,UAAU,EAAhB;AACA9B,cAAY2B,IAAZ,EAAkB,UAACjB,IAAD,EAAU;AAC1B,QAAIkB,GAAGlB,IAAH,CAAJ,EAAc;AACZoB,cAAQC,IAAR,CAAarB,IAAb;AACD;AACF,GAJD;AAKA,SAAOoB,OAAP;AACD;;AAED;;;;;;;;;;AAUO,SAAS5B,cAAT,CAAwB8B,IAAxB,EAA8BC,UAA9B,EAA0C;AAC/C,MAAMH,UAAU7B,WACd+B,IADc,EAEd,UAACtB,IAAD,EAAU;AACR,QAAI,CAACA,KAAKQ,QAAV,EAAoB;AAClB,aAAO,KAAP;AACD;;AAED,WAAOpB,eAAeY,IAAf,EAAqBgB,OAArB,CAA6BO,UAA7B,MAA6C,CAAC,CAArD;AACD,GARa,CAAhB;AAUA,SAAOH,QAAQ,CAAR,KAAc,IAArB;AACD;;AAED,SAASI,UAAT,CAAoBC,IAApB,EAA0BP,EAA1B,EAA8B;AAC5B,SAAOO,KAAKC,MAAL,CAAY;AAAA,WAAQnC,WAAW0B,IAAX,EAAiBC,EAAjB,EAAqBS,MAArB,KAAgC,CAAxC;AAAA,GAAZ,CAAP;AACD;;AAEM,SAASlC,UAAT,CAAoBO,IAApB,EAA0BsB,IAA1B,EAAgC;AACrC,MAAMM,QAAQ,CAACN,IAAD,CAAd;AACA,MAAMG,OAAO,EAAb;;AAEA,MAAMI,UAAU,SAAVA,OAAU;AAAA,WAAY7B,SAAS8B,QAArB;AAAA,GAAhB;;AAEA,SAAOF,MAAMD,MAAb,EAAqB;AACnB,QAAMI,UAAUH,MAAMI,GAAN,EAAhB;AACA,QAAMC,WAAW7C,eAAe2C,OAAf,CAAjB;AACA,QAAIA,YAAY/B,IAAhB,EAAsB,OAAOwB,WAAWC,IAAX,EAAiBI,OAAjB,CAAP;;AAEtBJ,SAAKJ,IAAL,CAAUU,OAAV;;AAEA,QAAIE,SAASN,MAAT,KAAoB,CAAxB,EAA2B;AACzB;AACAF,WAAKO,GAAL;AACD;AACDJ,UAAMP,IAAN,iCAAcY,QAAd;AACD;;AAED,SAAO,IAAP;AACD;;AAEM,SAASvC,aAAT,CAAuBM,IAAvB,EAA6BsB,IAA7B,EAAmC;AACxC,SAAO,CAAC7B,WAAWO,IAAX,EAAiBsB,IAAjB,KAA0B,EAA3B,EAA+BY,OAA/B,EAAP;AACD;;AAEM,SAASvC,SAAT,CAAmBK,IAAnB,EAAyBmC,EAAzB,EAA6B;AAClC,SAAOhD,YAAYa,IAAZ,EAAkBmC,EAAlB,KAAyBA,EAAhC;AACD;;AAED,IAAMC,kBAAkB,EAAxB;AACA,SAASC,gBAAT,CAA0BC,CAA1B,EAA6B;AAC3B,SAAO,OAAOA,CAAP,KAAa,WAAb,GAA2BA,CAA3B,GAA+BF,eAAtC;AACD;AACD,SAASG,sBAAT,CAAgCC,GAAhC,EAAqC;AACnC,SAAO,yBAAQA,GAAR,EACJC,MADI,CACG,UAACC,GAAD;AAAA;AAAA,QAAOC,CAAP;AAAA,QAAUL,CAAV;;AAAA,wCAAuBI,GAAvB,sBAA6BC,CAA7B,EAAiCN,iBAAiBC,CAAjB,CAAjC;AAAA,GADH,EAC4D,EAD5D,CAAP;AAED;;AAEM,SAAS1C,sBAAT,CAAgCI,IAAhC,EAAsCC,KAAtC,EAA6C;AAClD,SAAO,2BAASd,YAAYa,IAAZ,CAAT,EAA4BuC,uBAAuBtC,KAAvB,CAA5B,CAAP;AACD;;AAED,SAAS2C,mBAAT,CAA6BC,QAA7B,EAAuC;AACrC,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChC,WAAOhC,OAAOgC,YAAY,EAAnB,CAAP;AACD;AACD,MAAI,CAACA,QAAL,EAAe;AACb,WAAO,EAAP;AACD;AACD,SAAOA,SAASC,WAAT,IAAwB,EAA/B;AACD;;AAED,SAASC,kBAAT,CAA4B/C,IAA5B,SAKG;AAAA,MAJDgD,SAIC,SAJDA,SAIC;AAAA,MAHDC,eAGC,SAHDA,eAGC;AAAA,MAFDC,OAEC,SAFDA,OAEC;AAAA,oCADDC,qBACC;AAAA,MADDA,qBACC,yCADuB,KACvB;;AACD,MAAInD,QAAQ,IAAZ,EAAkB;AAChB,WAAO,EAAP;AACD;;AAED,MAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,QAAhD,EAA0D;AACxD,WAAOa,OAAOb,IAAP,CAAP;AACD;;AAED,MAAIgD,aAAahD,KAAKoD,IAAlB,IAA0B,OAAOpD,KAAKoD,IAAZ,KAAqB,UAAnD,EAA+D;AAC7D,WAAOJ,UAAUhD,IAAV,CAAP;AACD;;AAED,MAAIiD,mBAAmBjD,KAAKqD,QAAL,KAAkB,MAAzC,EAAiD;AAC/C,WAAOJ,gBAAgBjD,IAAhB,CAAP;AACD;AACD,MAAIA,KAAKQ,QAAL,IAAiB,IAAjB,IAAyB2C,qBAA7B,EAAoD;AAClD,WAAO,IAAP;AACD;AACD,SAAO/D,eAAeY,IAAf,EAAqBS,GAArB,CAAyByC,OAAzB,EAAkCI,IAAlC,CAAuC,EAAvC,CAAP;AACD;;AAEM,SAASzD,eAAT,CAAyBG,IAAzB,EAA+B;AACpC,SAAO+C,mBAAmB/C,IAAnB,EAAyB;AAC9BkD,aAASrD,eADqB;AAE9BmD,aAF8B;AAAA,gCAEV;AAAA,YAARI,IAAQ,SAARA,IAAQ;;AAClB,4BAAWA,KAAKG,WAAL,IAAoB,oCAAaH,IAAb,CAA/B;AACD;;AAJ6B;AAAA;AAAA,GAAzB,CAAP;AAMD;;AAEM,SAAStD,oBAAT,CAA8BE,IAA9B,EAAoCE,OAApC,EAA6C;AAClD,SAAO6C,mBAAmB/C,IAAnB,EAAyB;AAC9BkD,WAD8B;AAAA,uBACtBM,IADsB,EAChB;AACZ,eAAO1D,qBAAqB0D,IAArB,EAA2BtD,OAA3B,CAAP;AACD;;AAH6B;AAAA;AAI9B+C,mBAJ8B;AAAA,+BAIdO,IAJc,EAIR;AACpB,YAAMC,QAAQ,GAAGC,MAAH,CAAUxD,QAAQyD,cAAR,CAAuBH,IAAvB,EAA6B,IAA7B,CAAV,CAAd;AACA,eAAOC,MAAMhD,GAAN,CAAUmC,mBAAV,EAA+BU,IAA/B,CAAoC,EAApC,CAAP;AACD;;AAP6B;AAAA;AAAA,GAAzB,CAAP;AASD;;AAED,SAASM,mBAAT,CAA6Bf,QAA7B,EAAuC;AACrC,MAAIA,YAAY,IAAhB,EAAsB;AACpB,WAAO,IAAP;AACD;AACD,SAAOA,SAASgB,SAAT,CAAmB/C,OAAnB,CAA2B,yCAA3B,EAAsE,EAAtE,CAAP;AACD;;AAEM,SAASf,oBAAT,CAA8BC,IAA9B,EAAoCE,OAApC,EAA6C;AAClD,SAAO6C,mBAAmB/C,IAAnB,EAAyB;AAC9BkD,WAD8B;AAAA,uBACtBM,IADsB,EAChB;AACZ,eAAOzD,qBAAqByD,IAArB,EAA2BtD,OAA3B,CAAP;AACD;;AAH6B;AAAA;AAI9B+C,mBAJ8B;AAAA,+BAIdO,IAJc,EAIR;AACpB,YAAMC,QAAQ,GAAGC,MAAH,CAAUxD,QAAQyD,cAAR,CAAuBH,IAAvB,EAA6B,IAA7B,CAAV,CAAd;AACA,eAAOC,MAAMhD,GAAN,CAAUmD,mBAAV,EAA+BN,IAA/B,CAAoC,EAApC,CAAP;AACD;;AAP6B;AAAA;;AAQ9BH,2BAAuB;AARO,GAAzB,CAAP;AAUD","file":"RSTTraversal.js","sourcesContent":["import flat from 'array.prototype.flat';\nimport entries from 'object.entries';\nimport isSubset from 'is-subset';\nimport functionName from 'function.prototype.name';\nimport isRegex from 'is-regex';\nimport getAdapter from './getAdapter';\n\nexport function propsOfNode(node) {\n  return (node && node.props) || {};\n}\n\nexport function childrenOfNode(node) {\n  if (!node) return [];\n\n  const adapter = getAdapter();\n  const adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n\n  const renderedArray = Array.isArray(node.rendered) ? flat(node.rendered, 1) : [node.rendered];\n\n  // React adapters before 16 will not have isFragment\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return flat(renderedArray.map((currentChild) => {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nexport function hasClassName(node, className) {\n  let classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if (isRegex(className)) return className.test(classes);\n  return ` ${classes} `.indexOf(` ${className} `) > -1;\n}\n\nexport function treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n  childrenOfNode(tree).forEach(node => treeForEach(node, fn));\n}\n\nexport function treeFilter(tree, fn) {\n  const results = [];\n  treeForEach(tree, (node) => {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\nexport function findParentNode(root, targetNode) {\n  const results = treeFilter(\n    root,\n    (node) => {\n      if (!node.rendered) {\n        return false;\n      }\n\n      return childrenOfNode(node).indexOf(targetNode) !== -1;\n    },\n  );\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter(tree => treeFilter(tree, fn).length !== 0);\n}\n\nexport function pathToNode(node, root) {\n  const queue = [root];\n  const path = [];\n\n  const hasNode = testNode => node === testNode;\n\n  while (queue.length) {\n    const current = queue.pop();\n    const children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n    queue.push(...children);\n  }\n\n  return null;\n}\n\nexport function parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nexport function nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nconst CAN_NEVER_MATCH = {};\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\nfunction replaceUndefinedValues(obj) {\n  return entries(obj)\n    .reduce((acc, [k, v]) => ({ ...acc, [k]: replaceUndefined(v) }), {});\n}\n\nexport function nodeMatchesObjectProps(node, props) {\n  return isSubset(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n  if (!hostNode) {\n    return '';\n  }\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, {\n  getCustom,\n  handleHostNodes,\n  recurse,\n  nullRenderReturnsNull = false,\n}) {\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nexport function getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom({ type }) {\n      return `<${type.displayName || functionName(type)} />`;\n    },\n  });\n}\n\nexport function getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getTextFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getTextFromHostNode).join('');\n    },\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nexport function getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getHTMLFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getHTMLFromHostNode).join('');\n    },\n    nullRenderReturnsNull: true,\n  });\n}\n"]}},"error":null,"hash":"7a2787b9d9911afc200ed9983a21e9a5","cacheData":{"env":{}}}