{"id":"node_modules/enzyme-adapter-utils/build/createMountWrapper.js","dependencies":[{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/package.json","includedInParent":true,"mtime":1574135091811},{"name":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme-adapter-utils/package.json","includedInParent":true,"mtime":1574134609548},{"name":"object.assign","loc":{"line":13,"column":22},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme-adapter-utils/build/createMountWrapper.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/object.assign/index.js"},{"name":"react","loc":{"line":17,"column":21},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme-adapter-utils/build/createMountWrapper.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/react/index.js"},{"name":"prop-types","loc":{"line":21,"column":25},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme-adapter-utils/build/createMountWrapper.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/prop-types/index.js"},{"name":"airbnb-prop-types","loc":{"line":25,"column":31},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme-adapter-utils/build/createMountWrapper.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/airbnb-prop-types/index.js"},{"name":"./RootFinder","loc":{"line":27,"column":26},"parent":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme-adapter-utils/build/createMountWrapper.js","resolved":"/Users/abu-zaydabdullah/Documents/congressconversation/node_modules/enzyme-adapter-utils/build/RootFinder.js"}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports['default'] = createMountWrapper;\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _airbnbPropTypes = require('airbnb-prop-types');\n\nvar _RootFinder = require('./RootFinder');\n\nvar _RootFinder2 = _interopRequireDefault(_RootFinder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/* eslint react/forbid-prop-types: 0 */\n\nvar stringOrFunction = _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].string]);\nvar makeValidElementType = function makeValidElementType(adapter) {\n  if (!adapter) {\n    return stringOrFunction;\n  }\n\n  function validElementType(props, propName) {\n    if (!adapter.isValidElementType) {\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      return stringOrFunction.apply(undefined, [props, propName].concat(args));\n    }\n    var propValue = props[propName];\n    if (propValue == null || adapter.isValidElementType(propValue)) {\n      return null;\n    }\n    return new TypeError(String(propName) + ' must be a valid element type!');\n  }\n  validElementType.isRequired = function () {\n    function validElementTypeRequired(props, propName) {\n      if (!adapter.isValidElementType) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n\n        return stringOrFunction.isRequired.apply(stringOrFunction, [props, propName].concat(args));\n      }\n      var propValue = props[propName]; // eslint-disable-line react/destructuring-assignment\n      if (adapter.isValidElementType(propValue)) {\n        return null;\n      }\n      return new TypeError(String(propName) + ' must be a valid element type!');\n    }\n\n    return validElementTypeRequired;\n  }();\n  return validElementType;\n};\n\n/**\n * This is a utility component to wrap around the nodes we are\n * passing in to `mount()`. Theoretically, you could do everything\n * we are doing without this, but this makes it easier since\n * `renderIntoDocument()` doesn't really pass back a reference to\n * the DOM node it rendered to, so we can't really \"re-render\" to\n * pass new props in.\n */\nfunction createMountWrapper(node) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var adapter = options.adapter,\n      WrappingComponent = options.wrappingComponent;\n\n  var WrapperComponent = function (_React$Component) {\n    _inherits(WrapperComponent, _React$Component);\n\n    function WrapperComponent() {\n      var _ref;\n\n      _classCallCheck(this, WrapperComponent);\n\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var _this = _possibleConstructorReturn(this, (_ref = WrapperComponent.__proto__ || Object.getPrototypeOf(WrapperComponent)).call.apply(_ref, [this].concat(args)));\n\n      var _this$props = _this.props,\n          props = _this$props.props,\n          wrappingComponentProps = _this$props.wrappingComponentProps,\n          context = _this$props.context;\n\n      _this.state = {\n        mount: true,\n        props: props,\n        wrappingComponentProps: wrappingComponentProps,\n        context: context\n      };\n      return _this;\n    }\n\n    _createClass(WrapperComponent, [{\n      key: 'setChildProps',\n      value: function () {\n        function setChildProps(newProps, newContext) {\n          var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n          var _state = this.state,\n              oldProps = _state.props,\n              oldContext = _state.context;\n\n          var props = (0, _object2['default'])({}, oldProps, newProps);\n          var context = (0, _object2['default'])({}, oldContext, newContext);\n          this.setState({ props: props, context: context }, callback);\n        }\n\n        return setChildProps;\n      }()\n    }, {\n      key: 'setWrappingComponentProps',\n      value: function () {\n        function setWrappingComponentProps(props) {\n          var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n          this.setState({ wrappingComponentProps: props }, callback);\n        }\n\n        return setWrappingComponentProps;\n      }()\n    }, {\n      key: 'render',\n      value: function () {\n        function render() {\n          var _props = this.props,\n              Component = _props.Component,\n              refProp = _props.refProp;\n          var _state2 = this.state,\n              mount = _state2.mount,\n              props = _state2.props,\n              wrappingComponentProps = _state2.wrappingComponentProps;\n\n          if (!mount) return null;\n          // eslint-disable-next-line react/jsx-props-no-spreading\n          var component = _react2['default'].createElement(Component, _extends({ ref: refProp }, props));\n          if (WrappingComponent) {\n            return (\n              // eslint-disable-next-line react/jsx-props-no-spreading\n              _react2['default'].createElement(\n                WrappingComponent,\n                wrappingComponentProps,\n                _react2['default'].createElement(\n                  _RootFinder2['default'],\n                  null,\n                  component\n                )\n              )\n            );\n          }\n          return component;\n        }\n\n        return render;\n      }()\n    }]);\n\n    return WrapperComponent;\n  }(_react2['default'].Component);\n\n  WrapperComponent.propTypes = {\n    Component: makeValidElementType(adapter).isRequired,\n    refProp: _propTypes2['default'].oneOfType([_propTypes2['default'].string, (0, _airbnbPropTypes.ref)()]),\n    props: _propTypes2['default'].object.isRequired,\n    wrappingComponentProps: _propTypes2['default'].object,\n    context: _propTypes2['default'].object\n  };\n  WrapperComponent.defaultProps = {\n    refProp: null,\n    context: null,\n    wrappingComponentProps: null\n  };\n\n  if (options.context && (node.type.contextTypes || options.childContextTypes)) {\n    // For full rendering, we are using this wrapper component to provide context if it is\n    // specified in both the options AND the child component defines `contextTypes` statically\n    // OR the merged context types for all children (the node component or deeper children) are\n    // specified in options parameter under childContextTypes.\n    // In that case, we define both a `getChildContext()` function and a `childContextTypes` prop.\n    var childContextTypes = (0, _object2['default'])({}, node.type.contextTypes, options.childContextTypes);\n\n    WrapperComponent.prototype.getChildContext = function () {\n      function getChildContext() {\n        return this.state.context;\n      }\n\n      return getChildContext;\n    }();\n    WrapperComponent.childContextTypes = childContextTypes;\n  }\n  return WrapperComponent;\n}\n\n//# sourceMappingURL=createMountWrapper.js.map"},"sourceMaps":{"js":{"version":3,"sources":["../src/createMountWrapper.jsx"],"names":["createMountWrapper","stringOrFunction","PropTypes","oneOfType","func","string","makeValidElementType","adapter","validElementType","props","propName","isValidElementType","args","propValue","TypeError","isRequired","validElementTypeRequired","node","options","WrappingComponent","wrappingComponent","WrapperComponent","wrappingComponentProps","context","state","mount","newProps","newContext","callback","undefined","oldProps","oldContext","setState","Component","refProp","component","React","propTypes","object","defaultProps","type","contextTypes","childContextTypes","prototype","getChildContext"],"mappings":";;;;;;;;;;qBA4CwBA,kB;;;;;;AA5CxB;;;;AACA;;;;AACA;;AACA;;;;;;;;;;;;AAEA;;AAEA,IAAMC,mBAAmBC,uBAAUC,SAAV,CAAoB,CAACD,uBAAUE,IAAX,EAAiBF,uBAAUG,MAA3B,CAApB,CAAzB;AACA,IAAMC,uBAAuB,SAAvBA,oBAAuB,CAACC,OAAD,EAAa;AACxC,MAAI,CAACA,OAAL,EAAc;AACZ,WAAON,gBAAP;AACD;;AAED,WAASO,gBAAT,CAA0BC,KAA1B,EAAiCC,QAAjC,EAAoD;AAClD,QAAI,CAACH,QAAQI,kBAAb,EAAiC;AAAA,wCADWC,IACX;AADWA,YACX;AAAA;;AAC/B,aAAOX,mCAAiBQ,KAAjB,EAAwBC,QAAxB,SAAqCE,IAArC,EAAP;AACD;AACD,QAAMC,YAAYJ,MAAMC,QAAN,CAAlB;AACA,QAAIG,aAAa,IAAb,IAAqBN,QAAQI,kBAAR,CAA2BE,SAA3B,CAAzB,EAAgE;AAC9D,aAAO,IAAP;AACD;AACD,WAAO,IAAIC,SAAJ,QAAiBJ,QAAjB,qCAAP;AACD;AACDF,mBAAiBO,UAAjB;AAA8B,aAASC,wBAAT,CAAkCP,KAAlC,EAAyCC,QAAzC,EAA4D;AACxF,UAAI,CAACH,QAAQI,kBAAb,EAAiC;AAAA,2CADiDC,IACjD;AADiDA,cACjD;AAAA;;AAC/B,eAAOX,iBAAiBc,UAAjB,0BAA4BN,KAA5B,EAAmCC,QAAnC,SAAgDE,IAAhD,EAAP;AACD;AACD,UAAMC,YAAYJ,MAAMC,QAAN,CAAlB,CAJwF,CAIrD;AACnC,UAAIH,QAAQI,kBAAR,CAA2BE,SAA3B,CAAJ,EAA2C;AACzC,eAAO,IAAP;AACD;AACD,aAAO,IAAIC,SAAJ,QAAiBJ,QAAjB,qCAAP;AACD;;AATD,WAAuCM,wBAAvC;AAAA;AAUA,SAAOR,gBAAP;AACD,CA1BD;;AA4BA;;;;;;;;AAQe,SAASR,kBAAT,CAA4BiB,IAA5B,EAAgD;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAAA,MACrDX,OADqD,GACHW,OADG,CACrDX,OADqD;AAAA,MACzBY,iBADyB,GACHD,OADG,CAC5CE,iBAD4C;;AAAA,MAGvDC,gBAHuD;AAAA;;AAI3D,gCAAqB;AAAA;;AAAA;;AAAA,yCAANT,IAAM;AAANA,YAAM;AAAA;;AAAA,iKACVA,IADU;;AAAA,wBAEgC,MAAKH,KAFrC;AAAA,UAEXA,KAFW,eAEXA,KAFW;AAAA,UAEJa,sBAFI,eAEJA,sBAFI;AAAA,UAEoBC,OAFpB,eAEoBA,OAFpB;;AAGnB,YAAKC,KAAL,GAAa;AACXC,eAAO,IADI;AAEXhB,oBAFW;AAGXa,sDAHW;AAIXC;AAJW,OAAb;AAHmB;AASpB;;AAb0D;AAAA;AAAA;AAAA,+BAe7CG,QAf6C,EAenCC,UAfmC,EAeD;AAAA,cAAtBC,QAAsB,uEAAXC,SAAW;AAAA,uBACP,KAAKL,KADE;AAAA,cACzCM,QADyC,UAChDrB,KADgD;AAAA,cACtBsB,UADsB,UAC/BR,OAD+B;;AAExD,cAAMd,qCAAaqB,QAAb,EAA0BJ,QAA1B,CAAN;AACA,cAAMH,uCAAeQ,UAAf,EAA8BJ,UAA9B,CAAN;AACA,eAAKK,QAAL,CAAc,EAAEvB,YAAF,EAASc,gBAAT,EAAd,EAAkCK,QAAlC;AACD;;AApB0D;AAAA;AAAA;AAAA;AAAA;AAAA,2CAsBjCnB,KAtBiC,EAsBJ;AAAA,cAAtBmB,QAAsB,uEAAXC,SAAW;;AACrD,eAAKG,QAAL,CAAc,EAAEV,wBAAwBb,KAA1B,EAAd,EAAiDmB,QAAjD;AACD;;AAxB0D;AAAA;AAAA;AAAA;AAAA;AAAA,0BA0BlD;AAAA,uBACwB,KAAKnB,KAD7B;AAAA,cACCwB,SADD,UACCA,SADD;AAAA,cACYC,OADZ,UACYA,OADZ;AAAA,wBAE0C,KAAKV,KAF/C;AAAA,cAECC,KAFD,WAECA,KAFD;AAAA,cAEQhB,KAFR,WAEQA,KAFR;AAAA,cAEea,sBAFf,WAEeA,sBAFf;;AAGP,cAAI,CAACG,KAAL,EAAY,OAAO,IAAP;AACZ;AACA,cAAMU,YAAY,iCAAC,SAAD,aAAW,KAAKD,OAAhB,IAA6BzB,KAA7B,EAAlB;AACA,cAAIU,iBAAJ,EAAuB;AACrB;AACE;AACA;AAAC,iCAAD;AAAuBG,sCAAvB;AACE;AAAC,yCAAD;AAAA;AAAaa;AAAb;AADF;AAFF;AAMD;AACD,iBAAOA,SAAP;AACD;;AAzC0D;AAAA;AAAA;;AAAA;AAAA,IAG9BC,mBAAMH,SAHwB;;AA2C7DZ,mBAAiBgB,SAAjB,GAA6B;AAC3BJ,eAAW3B,qBAAqBC,OAArB,EAA8BQ,UADd;AAE3BmB,aAAShC,uBAAUC,SAAV,CAAoB,CAACD,uBAAUG,MAAX,EAAmB,2BAAnB,CAApB,CAFkB;AAG3BI,WAAOP,uBAAUoC,MAAV,CAAiBvB,UAHG;AAI3BO,4BAAwBpB,uBAAUoC,MAJP;AAK3Bf,aAASrB,uBAAUoC;AALQ,GAA7B;AAOAjB,mBAAiBkB,YAAjB,GAAgC;AAC9BL,aAAS,IADqB;AAE9BX,aAAS,IAFqB;AAG9BD,4BAAwB;AAHM,GAAhC;;AAMA,MAAIJ,QAAQK,OAAR,KAAoBN,KAAKuB,IAAL,CAAUC,YAAV,IAA0BvB,QAAQwB,iBAAtD,CAAJ,EAA8E;AAC5E;AACA;AACA;AACA;AACA;AACA,QAAMA,iDACDzB,KAAKuB,IAAL,CAAUC,YADT,EAEDvB,QAAQwB,iBAFP,CAAN;;AAKArB,qBAAiBsB,SAAjB,CAA2BC,eAA3B;AAA6C,eAASA,eAAT,GAA2B;AACtE,eAAO,KAAKpB,KAAL,CAAWD,OAAlB;AACD;;AAFD,aAAsDqB,eAAtD;AAAA;AAGAvB,qBAAiBqB,iBAAjB,GAAqCA,iBAArC;AACD;AACD,SAAOrB,gBAAP;AACD","file":"createMountWrapper.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { ref } from 'airbnb-prop-types';\nimport RootFinder from './RootFinder';\n\n/* eslint react/forbid-prop-types: 0 */\n\nconst stringOrFunction = PropTypes.oneOfType([PropTypes.func, PropTypes.string]);\nconst makeValidElementType = (adapter) => {\n  if (!adapter) {\n    return stringOrFunction;\n  }\n\n  function validElementType(props, propName, ...args) {\n    if (!adapter.isValidElementType) {\n      return stringOrFunction(props, propName, ...args);\n    }\n    const propValue = props[propName];\n    if (propValue == null || adapter.isValidElementType(propValue)) {\n      return null;\n    }\n    return new TypeError(`${propName} must be a valid element type!`);\n  }\n  validElementType.isRequired = function validElementTypeRequired(props, propName, ...args) {\n    if (!adapter.isValidElementType) {\n      return stringOrFunction.isRequired(props, propName, ...args);\n    }\n    const propValue = props[propName]; // eslint-disable-line react/destructuring-assignment\n    if (adapter.isValidElementType(propValue)) {\n      return null;\n    }\n    return new TypeError(`${propName} must be a valid element type!`);\n  };\n  return validElementType;\n};\n\n/**\n * This is a utility component to wrap around the nodes we are\n * passing in to `mount()`. Theoretically, you could do everything\n * we are doing without this, but this makes it easier since\n * `renderIntoDocument()` doesn't really pass back a reference to\n * the DOM node it rendered to, so we can't really \"re-render\" to\n * pass new props in.\n */\nexport default function createMountWrapper(node, options = {}) {\n  const { adapter, wrappingComponent: WrappingComponent } = options;\n\n  class WrapperComponent extends React.Component {\n    constructor(...args) {\n      super(...args);\n      const { props, wrappingComponentProps, context } = this.props;\n      this.state = {\n        mount: true,\n        props,\n        wrappingComponentProps,\n        context,\n      };\n    }\n\n    setChildProps(newProps, newContext, callback = undefined) {\n      const { props: oldProps, context: oldContext } = this.state;\n      const props = { ...oldProps, ...newProps };\n      const context = { ...oldContext, ...newContext };\n      this.setState({ props, context }, callback);\n    }\n\n    setWrappingComponentProps(props, callback = undefined) {\n      this.setState({ wrappingComponentProps: props }, callback);\n    }\n\n    render() {\n      const { Component, refProp } = this.props;\n      const { mount, props, wrappingComponentProps } = this.state;\n      if (!mount) return null;\n      // eslint-disable-next-line react/jsx-props-no-spreading\n      const component = <Component ref={refProp} {...props} />;\n      if (WrappingComponent) {\n        return (\n          // eslint-disable-next-line react/jsx-props-no-spreading\n          <WrappingComponent {...wrappingComponentProps}>\n            <RootFinder>{component}</RootFinder>\n          </WrappingComponent>\n        );\n      }\n      return component;\n    }\n  }\n  WrapperComponent.propTypes = {\n    Component: makeValidElementType(adapter).isRequired,\n    refProp: PropTypes.oneOfType([PropTypes.string, ref()]),\n    props: PropTypes.object.isRequired,\n    wrappingComponentProps: PropTypes.object,\n    context: PropTypes.object,\n  };\n  WrapperComponent.defaultProps = {\n    refProp: null,\n    context: null,\n    wrappingComponentProps: null,\n  };\n\n  if (options.context && (node.type.contextTypes || options.childContextTypes)) {\n    // For full rendering, we are using this wrapper component to provide context if it is\n    // specified in both the options AND the child component defines `contextTypes` statically\n    // OR the merged context types for all children (the node component or deeper children) are\n    // specified in options parameter under childContextTypes.\n    // In that case, we define both a `getChildContext()` function and a `childContextTypes` prop.\n    const childContextTypes = {\n      ...node.type.contextTypes,\n      ...options.childContextTypes,\n    };\n\n    WrapperComponent.prototype.getChildContext = function getChildContext() {\n      return this.state.context;\n    };\n    WrapperComponent.childContextTypes = childContextTypes;\n  }\n  return WrapperComponent;\n}\n"]}},"error":null,"hash":"5bd23d0c8d355f8744c6fc94757e4b1c","cacheData":{"env":{}}}